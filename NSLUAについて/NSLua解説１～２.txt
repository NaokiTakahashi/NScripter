■■はじめに■■
このテキスト文書はnslua.dllの使い方の覚書です。
ここでいう「高水準」「低水準」とは、出来ることの高度さなどの意味ではなく、
「高水準＝NScripterの文法に近い　低水準＝Lua関数に近い」程度の意味です。
だいたい同じことができて、低水準関数のほうが若干速いです。
もっとも、速度差は微々たる物です。画面更新にかかる時間の百分の一以下で、無視できます。
低水準インタフェースは、NScripterの文法から離れてLua側の関数呼び出しで直接かけるので
複雑なLuaのコードを書く人にとっては楽です。
高水準インタフェースは、NScripterのスクリプトをそのまま使えます。

＜Luaについて＞
nslua.dllはオープンソースのスクリプト言語Luaのコードを使っています。
LuaはMITライクなライセンスなので、著作権の所在をはっきり書いておけばそれだけで使えます。
http://www.lua.org/

＜nslua.dllの仕様＞
nslua.dllをNScripterの実行ファイルと同じフォルダにおいておくと、
NScripterにLuaスクリプト機能をが追加されます。

nslua.dllは、system.luaがあれば、それを起動時に自動で読み込みます。
ほかにスクリプトがある場合は、system.luaからさらにNL_dofile関数を呼んでください。

●NL_dofile(Luaスクリプトファイル名)
例）
NL_dofile("lib.lua")
Lua標準関数のdofileではNSAやNS2アーカイブの中のファイルは実行できませんが、
NL_dofileはアーカイブの中のファイルも実行できます。
もちろん、system.luaもアーカイブの中から実行できます。



■■第一章　高水準インタフェース編■■

※実例はサンプル１をごらんください。
■NScripterからLuaを呼び出す方法
【luasub命令】
define節命令です。
命令名を受け取り、それをLua側のNSCOM_(命令名)という関数に結び付けます。
例）
luasub func
この命令を実行すると、以後シナリオスクリプト（00.txt〜）でfunc命令を実行したときに、
Lua関数 NSCOM_func() が呼び出されます。
luasubで登録されるLua関数には引数も戻り値もありません。
引数や戻り値はそれぞれ下で説明している関数を使って利用してください。
なお、既存の命令も上書きできます。
たとえばluasub bgとすると、もともとのbg命令ではなくluaのNSCOM_bg関数が優先されます。
もともとのbg命令を呼びたい場合は、defsubのときと同様_bgとしてください。


■NScripterからの引数を受け取る方法
次のLua関数が用意されています。
引数がある場合は、使う使わないにかかわらず、全部これらの関数で受け取ってください。
これらの関数は内部で引数のエラーチェックをしています。
引数がない場合はこれらで引数を受け取る必要はありません。

●NSPopInt NScripterの数値の引数をひとつ読み込みます。
例）
number=NSPopInt()

●NSPopIntRef NScripterの数値変数引数の番号をひとつ読み込みます。%5なら5です。
例）
ivalindex=NSPopIntRef()

●NSPopStr NScripterの文字列の引数をひとつ読み込みます。
例）
str=NSPopStr()

●NSPopStrRef NScripterの文字列変数引数の番号をひとつ読み込みます。$10なら10です。
例）
svalindex=NSPopStrRef()

●NSPopLabel NScripterのラベル名をひとつ読み込みます。大文字だった場合小文字に変換されます。
例）
label=NSPopLabel()

●NSPopID NScripterの識別子形式の文字列の引数をひとつ読み込みます。大文字が含まれていた場合小文字に変換されます。
例）
id=NSPopID()
識別子形式とは、たとえばbg命令のblackやwhiteだとか、ld命令のl r cだとかのように、""で囲まれていない文字列です。

●NSPopComma 引数列のコンマをひとつ読み飛ばします。引数と引数の間には普通コンマがあります。
例）
NSPopComma()

●NSCheckComma 次の記号がコンマかどうかを調べます。読み込みはしません。引数の数を変えたいときに使います。
b=NSCheckComma() -- 次がコンマならb=true コンマでなければb=falseが代入される。


■LuaからNScripterの変数値を取得／設定する方法
次のLua関数が用意されています。
●NSSetIntValue NScripterの数値変数に値を設定します。
例）
NSSetIntValue(3,10) -- %3=10

●NSSetStrValue NScripterの文字列変数に値を設定します。
例）
NSSetStrValue(10,"test") -- $10="test"

●NSGetIntValue NScripterの数値変数から値を取得します。
例）
num=NSGetIntValue(10) -- %10の値が返る。

●NSGetStrValue NScripterの文字列変数から値を取得します。
例）
str=NSGetStrValue(12) -- $12の値が返る。

■LuaからNScripter命令を呼び出す方法
次のLua関数が用意されています。
●NSExec
　文字列で指定されたNScripterの命令を実行します。
　命令は一回にひとつだけです。:によるマルチステートメントは使えません。
　複数の命令を実行したい場合は、この命令を続けて複数回呼んでください。
　goto gosub selectなどジャンプが伴う命令、for next命令は使えません。
　命令がLuaを呼び出してもかまいませんが、そこからNSExecを二重に呼んではいけません。
　if文は使えますが、マルチステートメントが使えないので、Lua側のifのほうが書きやすいと思います。

例）
NSExec("amsp 10,100,50")

●NSGoto
　文字列で指定したラベルにgotoジャンプします。つまりシナリオスクリプトのgoto命令と等価です。
　ここで、ジャンプするのはあくまでシナリオスクリプト(00.txt等)の実行位置であり、
　Luaの実行はそのまま続行されることに注意してください。

例）
NSGoto ("*loop")

●NSGosub
　文字列で指定したラベルにgosubジャンプします。つまりシナリオスクリプトのgosub命令と等価です。
例）
NSGosub ("*sub")

●NSReturn
　シナリオスクリプトのサブルーチンからreturnします。つまりシナリオスクリプトのreturn命令と等価です。
例）
NSReturn()

●NSDoEvents
 時間のかかる関数からは時々これを呼んでWindowsのメッセージを処理してください。
 戻り値は終了フラグです。trueのときは直ちに関数から抜けてNScripterに処理を戻してください。
例）
b=NSDoEvents() -- b==trueのときは処理をやめてLua関数から抜けること

●NSOkBox
 ダイアログボックスを表示します。
 NScripterでいうmesbox命令ですが、本文とタイトルの指定順が逆になっていますのでご注意ください。
 （こちらのほうがWindowsでは標準のようなので、標準に従うことにしました。）
 本来は低水準のほうで説明するのが正しいのですが、プログラム中にも便利なのでこちらに書きます。
例）
NSOkBox("本文です","タイトルです。")


●NSYesNoBox
 はい／いいえをたずねるダイアログボックスを表示します。戻り値はbooleanです。
 NScripterでいうyesbox命令ですが、本文とタイトルが逆になっていますのでご注意ください。
例）
result=NSYesNoBox("質問です","タイトルです") -- はいを押せばresult=true、いいえならresult=false


■■第二章　コールバック編■■

※実例はサンプル２−１,２−２をごらんください。
NScripterのデフォルト動作のほとんどを、Lua関数で横取りすることができます。
表示文をスプライト機能で置き換えたり、システムカスタマイズなどをLuaで行えるようになります。

【luacall命令】
指定文字列は""で囲む必要はありません。また、大文字小文字も区別されません。
Lua側の関数名は、NSCALL_(指定文字列)となります。
Lua関数の引数や文字列は、それぞれの機能ごとに形式が定められています。
例）
luacall text
この命令を実行すると、以後表示文ごとにLua関数 NSCALL_text("表示文字列")を呼び出します。

指定できるコールバックは以下のとおりです。
★tag         表示文タグ      
　　デフォルトのpretextgosubのタイミングで呼び出されます。
　　function NSCALL_tag(tag) タグテキストを取得します。
　　戻り値：無し
　　この命令を使うとデフォルトの処理は行われなくなります。pregextgosubも無効になります。
　　（注意！）
　　NSCALL_tagからNSGotoやNSGosub等でジャンプしないでください。戻ってこれなくなります。

★text0       表示文（変換前）
    表示文の、表示テキストが渡されたタイミングで呼び出されます。
　　function NSCALL_text0(plainstr) この段階では変数を展開したり半角数字を全角に直したりしていません。
　　戻り値：なし。
　　自動で変換をしたくない場合はこちらを設定します。
　　この命令を使うと、デフォルトの変換処理やテキスト表示処理を呼び出しません。

★text        表示文（変換後）
　　表示文の、変換が終わったものが送られます。実際に表示される文字列です。
　　テキストを表示します。@や\を読み込んだら対応するクリック待ちも行ってください。
　　function NSCALL_text(printstr)
　　戻り値：無し
　　この命令を使うと、デフォルトの処理は行われなくなります。textgosubも無効になります。


★animation   アニメーション  
　　セルアニメーションと同じく、一定時間経過ごとに呼び出されます。
　　引数はありません。
　　戻り値にtrueを返すと画面を更新します。falseだと画面を更新しません。
　　function NSCALL_animation()
　　この命令に関係する以下３つのLua関数があります。低水準命令ですがここで紹介します。
　　なお、アニメーション割り込みとは言ってもマルチスレッドではありません。
　　通常セルアニメーションが発生するクリック待ちなどのところでこの関数も呼ばれるだけです。
　　この関数が呼ばれている間は他の動作はストップします。

　　●NSLuaAnimationInterval(intervalms)
　　　アニメーション割り込みの発生間隔を指定します。
　　　ミリ秒単位で指定出来ますが、その時間で必ず来るとは限りません。
　　　物理的に間に合わない場合はかなり遅れて飛んでくることになります。
　　　実際にどのタイミングで呼び出されたかは、NSTimer()を使って取得してください。
　　　デフォルトは15msです。
　　　例）
　　　NSLuaAnimationInterval(20) -- 20ミリ秒に一回呼ばれる

　　●NSLuaAnimationMode(boolswitch)
　　　NSLuaアニメーション割り込みを開始したり止めたり出来ます。
　　　デフォルトはfalseですので、設定が終わったらこの関数でtrueを指定して、
　　　割り込みを開始してください。Luaで操作したいオブジェクトがひとつもないときは、
　　　falseを指定して割り込みをとめることが出来ます。trueを指定すればまた割り込みが発生します。
　　　例）
　　　NSLuaAnimationMode(true)

　　●NSTimer
　　　1msに1増え続けるタイマーを取得します。resettimer gettimerと同じ精度です。
　　　正確にはアニメーション専用の関数ではなくいつでも呼び出せるものですが、これも紹介します。
　　　Windowsが起動してから経過したミリ秒を指すカウンタは、ひたすら増えていくだけです。
　　　この関数からは値を取得することしか出来ません。二回呼び出して、その差をとることで、
　　　経過時間が正確にわかります。
　　　例）
　　　count=NSTimer()

★close       閉じる          
　　ウィンドウの「閉じる」をクリックしたときの動作を指定します。
　　引数はありません。戻り値trueでプログラムを終了、falseでキャンセルです。
	この命令を使うと、デフォルトの処理（ダイアログ）は行われなくなります。
　　function NSCALL_close ()
　　戻り値：この後の動作（trueで終了処理の続行、falseでキャンセル）

★end         終了処理        
　　プログラムが終了する直前の動作を指定します。
　　引数も戻り値もありません。
　　function NSCALL_end ()
　　戻り値：無し


★savepoint   セーブポイント  
　　セーブポイントに到達したときに呼び出されます。
　　Lua側でセーブしておきたいデータがある場合はこの段階でメモリ内のセーブデータを更新してください。
　　引数も戻り値もありません。この命令を使っても、その後でデフォルトの処理はちゃんと行われます。
	なお、tag,text,text0のうちどれかをカスタマイズしているときは、セーブポイントは「saveon状態のときの各行頭（表示文でも命令文でも）」になります。
　　function NSCALL_savepoint()
　　戻り値：無し

★save        セーブ          
　　シナリオスクリプト側のデータが実際にセーブされる直前に呼び出されます。
　　セーブされるべきなのは、この関数が呼び出されたそのときのデータではなく、
　　最後に到達したセーブポイント時点でのデータです。間違わないようご注意ください。
　　引数はセーブ番号、戻り値はありません。
　　この命令を使っても、その後でデフォルトの処理はちゃんと行われます。
　　function NSCALL_Save(savenum)
　　戻り値：無し

★load        ロード          
　　セーブデータがロードされた直後に呼び出されます。
　　saveコールバック関数で保存したデータを読み込んで処理をしてください。
　　引数はセーブ番号、戻り値はありません。
　　function NSCALL_Load(savenum)
　　戻り値：無し

★reset　　　リセット
　　*define節からgame命令によって、もしくはリセットによって*startに飛んだときに呼ばれます。
　　なお、単にgoto *startでは呼ばれません（それはリセットではないので）。

define時に行いたい処理はsystem.luaに裸で書いておけば読み込み時に実行されます。


//---------------------------------
//以下工事中
//---------------------------------
★transition  トランジション  
　　どう実装するか考え中です。
　　最初からDLLに渡せるEffectDLLのほうが素直なのかも。