＜ビットマップ画像を直接画面に描画する関数＞

NSD〜系の関数群は、NScripterの描画命令系を通さずに画面に直接画像を書きこむものです。
NSDOffMode()とNSDTransition()を使えばトランジションエフェクトをかけることができます。
bltやdrawsp系の命令に近いですが、こちらは内部的にNScripter本体の描画処理とはまったく別の実装をしています。
したがって、NScripterの描画命令を使うと画像は保存されず上書きされます。
（残しておきたい場合は、背景画像としてなら、NSDCopyToBg()を使うことで残すことが出来ます）。

例えばLua内で完結するようなミニゲームを作るときは、こちらを使うと楽に作れるでしょう。
対応画像フォーマットは現状PNGのみになっています。

●NSDClear()
　画面を真っ黒でクリアします。

●NSDFill(lx,ly,rx,ry,r,g,b)
　画面の指定した領域を指定した色で塗りつぶします。
　それぞれ、左上の座標、右上の座標、RGBの指定（0〜255で）です。

●NSDLoad(num,filename)
　PNGファイルをテクスチャとしてロードします。アーカイブからでも裸でも読めます（ただし最新版のnspng.dllが必要）
　numはテクスチャ番号です。0から15が指定できます。
　この関数群は画像の一部を指定して転送することが出来ますので、一緒に使うチップは連結してまとめて置いてください。
　（これは、将来的にグラフィックカードのテクスチャ機能に置き換えるときに、テクスチャ切り替えを少なくして高速化するためです）
　なお、ファイル名には、PNG以外にも、塗りつぶし指定が出来ます。一文字目が「*」の場合は塗りつぶし指定になります。
　例）
　NSDLoad(2,"test.png") --テクスチャ2番にtest.pngを読み込みます。
　NSDLoad(3,"*32,32") -- テクスチャ3番に32x32ドットの完全透明画像を作成します。
　（色指定を省略すると完全透明なテクスチャになります。これはNSDLoadでは使い道がありませんが、後で説明するNSDCallで使います）
　NSDLoad(4,"*48,24,128,64,32,255") -- テクスチャ4番に48x24ドット、R=128 G=64 B=32 α=255で塗りつぶされた画像を作成します。

●NSDDelete(num)
　テクスチャを削除します。なお、明示的に削除しなくても、同じ番号にテクスチャをロードすると古いテクスチャは削除されます。
　使わなくなったテクスチャは削除するとメモリが節約できます。

●width,height=NSDGetSize(num)
　テクスチャのサイズを取得します。

●NSDBlt(num,dx,dy,w,h,sx,sy)
　テクスチャをそのまま画面にコピーします。
　numはテクスチャ番号です。
　dx,dyは転送先、画面上の左上の点の座標。sx,syは転送元、テクスチャ上の左上の点の座標、w,hは幅と高さです。
　矩形を重ね合わせを考慮せずそのままコピーしますので、ここから先で説明しているNSDSp〜系の命令よりも高速です。
　αブレンディングも重ね合わせや変形の必要もない画像はなるべくこの関数で描画してください。

●NSDSp(num,dx,dy,w,h,sx,sy,alpha)
　テクスチャをα値を考慮して重ね合わせで表示します。拡大縮小回転などの変形処理は行われません。
　numはテクスチャ番号です。
　dx,dyは転送先、画面上の左上の点の座標。sx,syは転送元、テクスチャ上の左上の点の座標、w,hは幅と高さ、alphaは全体のα値です。
　転送元のテクスチャ画像のα値をそのまま使いたい場合は、alphaには255を指定して下さい。

●NSDSpAdd(num,dx,dy,w,h,sx,sy,alpha)
　テクスチャをα値を考慮して、加算合成で表示します。その他はNSDSpと同じです。
（補足）
　現状では関係ありませんが、将来的にグラフィックカードの機能を使うときには、なるべくNSDSpAdd,NSDSp2AddとNSDSp,NSDSp2はまとめて実行したほうがいいです。
　そのほうがグラフィックカードのモード切替が減らせて、高速化されるからです。

●NSDSp2(num,dcx,dcy,sx,sy,w,h,xs,ys,rot,alpha)
　テクスチャを回転拡大縮小などの変形処理を加えて画面に転送します。
　numはテクスチャ番号です。
　dcx,dcyは転送先画面の「中心の」座標、sx,syは転送元テクスチャの「左上の」座標、w,hはテクスチャの「変形前の」幅と高さです。
　xs,ysは横・縦の倍率（少数で、1.0が元のサイズ）,rotは回転角（度単位で、少数で、0.0が回転無し）です。alphaは全体のα値です。

●NSDSp2Add(num,dcx,dcy,sx,sy,w,h,xs,ys,rot,alpha)
　テクスチャを回転拡大縮小などの変形処理を加えて、加算合成で画面に転送します。そのほかはNSDSp2と同じです。

●NSDPresent(),NSDPresentRect(lx,ly,rx,ry)
　画面を実際に更新します。ウィンドウ内が再描画されます。
　NSDPresent()は全画面、NSDPresetnRect(lx,ly,rx,ry)は指定した矩形領域が再描画されます（それぞれ左上座標、右上座標です）

●NSDCopyToBg()
　これらの画像処理は、NScripterの描画処理とは独立しています。
　したがって、Lua関数から抜けたり、Lua内部からNScripterの元々の機能を呼び出すと、描画している画像は全部上書きされてしまいます。
　残す必要がある場合は、この関数を実行することで、今現在の画面をNScripter上の「背景画面」としてコピーすることが出来ます。
　なお、この命令はNScripter側のBGロードと同じ処理をしていますので、立ち絵は全部消去されます。

●NSDOffMode(mode)
　NSDOffMode(true)で、NSD系命令の書きこみ先をオフスクリーンバッファに変更します。
　NSDOffMode(false)で、NSD系命令の書きこみ先は画面になります。デフォルトの書き込み先は画面です。
　NSDOffMode(true)の時は、NSDPresent、NSDPresentRectは使えません（画面には書きこんでいないため）。
　この命令は、次のNSDTransitionと組み合わせて、トランジションを実現するために使います。

●NSDTransition(effectnum,effecttime,rulename)
　NSDOffMode(true)でオフスクリーンに描き込まれた画像を、実際に画面に反映します。
　この関数は、一端画像をNScripterのデータに書き戻してNScripter側のエフェクト処理を呼んでいますので、NScripter側のエフェクトと同程度の重さの処理になります。
　NSD〜系の描画だけで実現できるエフェクトは、そちらで実装したほうが高速になります。
　このとき、NScripterと同じエフェクトが使えます。また、この関数は引数を省略できます。
　print 10,500と同じエフェクトを使いたい場合は、
　NSDTransition(10,500)
　print 18,1000,"rule.png"と同じエフェクトを使いたい場合は、
　NSDTransition(18,1000,"rule.png")です。
　（ルール画像の指定にはbmpも使えますが、PNGに統一したほうがややこしくないと思います。）

●NSDTransitionF(effectnum,effecttime,rulename)
　NSDTransition関数は、CTRLキーで高速化したりスペースやクリックでキャンセルしたり出来ます。
　NSDTransitionFは高速化やキャンセルが出来ないトランジションを実行します。
　そのほかはNSDTransitionと同じです。


●procnum=NSDDLL(dllname,funcname)
　NSD系命令のテクスチャ作成時に呼び出すDLL関数を設定します。Luaファイル読み込み時に一度だけ実行してください。
　DLLのサンプルが「NSDでフォントのDLL」フォルダにあります。自由に改造してかまいません。
　例）fontproc=NSDDLL("deffont.dll","Font") -- deffont.dll内のFont関数を読み込み、関数番号をfontprocに格納します。
　この番号をこの次に説明するNSDCall関数に指定します。

●NSDCall(texnum,filename,procnum(,param))
　テクスチャ作成時に、外部DLLを使ってテクスチャの中身をバイト単位で設定できます。
　NSD系のテクスチャは作成時の内容を変更することが出来ません。
　例えば、フォントを出力するような外部DLLを使って、文字フォントのテクスチャを作ることが出来ます。
　なお、引数paramがない場合は省略できます（この場合、DLLにはNULLが送られます）。
　例）
　NSDCall(10,"*200,60",fontproc,"20,20,あいうえお")
　--10番テクスチャをまず画像ファイル"*200,60"（つまり200x60の完全透明画像）で初期化し、その後、番号fontprocに登録したDLL関数を"20,20,あいうえお"という引数で呼び出します
　NSDCall(8,"test.png",filterproc,"gauss")
　--8番テクスチャをまずtest.pngで初期化し、番号filterprocに登録したDLL関数を"gauss"という引数で呼び出します。

　呼び出されるDLL関数の型は次の通りにしてください。
　void Func (unsigned char *ptr,int w,int h,const char *param);
　paramは呼び出し元から渡された文字列引数です。指定されなかった場合はNULLが入ります。
　wは画像の幅、hは画像の高さです。
　ptrはビットデータ配列です。
　(x,y)ピクセルのデータはptr[x*4+y*w*4]〜ptr[x*4+y*w*4+3]にあります。
　x*4+y*w*4=posとおくと、p[pos]=青 p[pos+1]=緑 p[pos+2]=赤 p[pos+3]=α値です。

●NSDSetSprite (spnum,texnum(,tag))
　NSD系命令用のテクスチャを、NScripterのスプライトに変換します。
　タグは省略すると"a;"になります。
　NSD系命令のテクスチャは常にα付きなので、:a以外には変換できません。
　NSD系命令のテクスチャにはセルやアニメ設定の概念がないので、設定が必要ならタグを指定する必要があります。
　例）
  NSDSetSprite(0,8) -- NScripterのスプライト0番にテクスチャ8番の画像を変換する。
  NSDSetSprite(3,10,":a/2,0,3;")-- NScripterのスプライト3番にテクスチャ10番の画像をセル数2アニメ無しで変換する。
  DLLで作ったフォント画像をNScripterのテクスチャにしたい時などに使えると思います。

●DLLのサンプル
　指定した文字列を出力するDLLのサンプルをdeffont.dllとして用意しました。
　パラメータには、"文字幅,文字高さ,文字列"を指定してください。半角全角どちらも表示できます。
　表示文字列中の半角の%はDLLへの命令に使う予定です。現在、文字色変更を実装しています。
　半角の%そのものを表示したい場合は、%%としてください。
　文字列中に%#色とすることで色を変えることが出来ます。色指定はHTMLと同じ要領で。
　なお、呼び出すたびに色は白に戻ります。最初から色を変えたい場合は文字列の頭で指定してください。

　（DLL設定の例）
　fontproc=NSDDLL("deffont.dll","Font") -- system.luaの直下で読み込み時に実行
　（使い方の例）
　NSDCall(0,"*200,48",fontproc,"24,24,あいうえお%#FF8888かきくけこ")

